# Design Principles

> _원문 : [React Blog](https://reactjs.org/docs/design-principles.html)_

> 이 문서를 작성하며 리액트가 무얼 하고, 하지 않을지를 어떻게 결정하는지
>
> 그리고 우리의 개발 철학이 어떤 것이지 더 잘 알수 있었다.

## Composition

리액트의 키는 커포넌트 조립이다.

각기 다른 사람들이 작성한 컴포넌트는 잘 작동해야한다.

코드베이스 전반에 걸쳐 영향을 끼치지 않으면서 컴포넌트에 기능을 추가할 수 있어야 한다.

예를 들어 컴포넌트가 사용하는 어떤 것도 변경하지 않고 어떠한 local state를 전할 수 있어야한다.

마찬가지로 초기화나 분해 코드 또한 컴포넌트에 필요하다면 추가할수 있어야한다.

---

state or lifecycle hook을 사용함에 나쁜점은 없다.

여타 강력한 기능 처럼, 그들을 적절히 사용해야 하고, 우리는 그들을 제거할 뜻이 없다.

오히려 그것들은 리액트를 강력하게 만들어주는 부분. 인정? 어 인정

우린 이후에 좀 더 [함수형 패턴](https://github.com/reactjs/react-future/tree/master/07%20-%20Returning%20State)을 추가할 수도 있겠지만,

local state and lifecycle hook은 여전히 그 모델의 일부분일 것이다.

---

간혹 컴포넌트들을 "단지 함수"라고 묘사하기도 하는데

우리의 관점에서 이들은 더욱 유용해저야 한다.

리액트에서, 컴포넌트들은 어떤 composable한 행동도 명세할 수 있고,

여기엔 렌더링, 생명주기, 상태도 포함된다.

[`Relay`](http://facebook.github.io/relay/)같은 외부 라이브러리는 데이터 의존성을 명세하는 컴포넌트처럼 다른 책무를 가진 컴포넌트를 증대시킨다.

이런 아이디어들은 어떤 형태로 리액트에 다시 들어갈 수도 있다.

## Common Abstraction

보통 우리는 사용자 단에서 구현할 수 있는 [기능추가를 주저](https://www.youtube.com/watch?v=4anAwXYqLG8)한다.

우린 당신의 코드가 쓸떼없는 라이브러리 코드로 차오르느걸 원치 않는다.

물론, 여기에도 예외는 있다.

---

예를 들어 리액트가 local state나 lifecycle hook 기능들을

제공하지 않았다면, 사람들은 그들만의 커스텀 추상화를 만들었을 것이다.

무수한 추상화들의 반목이 있을 것이고, 리액트는 그들을 강제하거나 그들만의 이점을 취하지 못할 것이다.

이들은 최소한의 공통분모만을 가지고 작동해야한다.

이것이 때때로 리액트에 기능을 추가하는 이유다.

우리가 호환성이 없거나 비효율적인 방식들로 구현된 특정 기능의

컴포넌트 구현을 주목하고 있다면 그것들을 리액트에 녹여낼 것이다.

물론 그것을 가벼이 행하지 않는다. 우리가 그러한 업데이트를 한다면

추상화 수준을 끌어올리는 것이 전체 생태계에 이익을 준다는 확신이 있기 때문이다.

상태, 생명주기 훅, 크로스 브라우져 이벤트 표준화가 그 좋은 예들이다.

우리는 항상 커뮤니티와 개선 제안을 논의 한다. 

리액트 이슈 트래커에서 ["big picture"](https://github.com/facebook/react/issues?q=is:open+is:issue+label:%22big+picture%22)라는 라벨로 이러한 논의를 찾아 볼 수 있다.


## Escape Hatches

리액트는 실용적이다. 페이스북 프로덕트에서 쓰일 필요에 의해 주도된다.

함수형 프로그래밍같은 주류가 아닌 패러다임의 영향을 받지만,

다양 기술과 경험 수준을 가진 다양한 개발자가 접근할 수 있는 상태를 유지하는 것이

프로젝트의 명시적인 목표다.

혹시 우리가 우리가 우리가 원치않는 패턴을 deprecate하려 한다면

그전에 존재하는 모든 실제 사례들을 고려한 [대안을 커뮤니티에 교육](https://reactjs.org/blog/2016/07/13/mixins-considered-harmful.html)해야할 책임이 있다.

앱을 만들기 유용한 몇몇 패턴이 선언적인 방식으로 표현하기 힘들다면

우리는 그것을 위한 [필수적인 API](https://reactjs.org/docs/refs-and-the-dom.html)를 제공할 것이다.

많은 앱에서 필수적인 무언가를 발견했지만 이를 위한 API를 알아낼 수 없다면

나중에 제거할수 있는 [임시 API를 제공](https://reactjs.org/docs/context.html)하고 향후 개선을 위한 문을 열어둘것이다.

## Stability

우린 API의 안정선을 평가한다. 페이스북에는 20000개가 넘는 리액트 컴포넌트가 있다.

다른 회사들처럼 리액트 헤비 유저다. 

그때문에 공공의 API나 행동의 변화를 꺼린다.

그렇다고 우리가 안정성을 "변치 않는것"이라 의미한다 생각하면 오산이다.

그렇게 된다면 빠르게 침체될 것이다.

대신에 우리는 

"대량의 프로덕션에서 사용되고 있는 것이 변해야 하다면 거기엔 명확한(되도록 자동화된) 마이그레이션 방법이 있을것이다"

라는 의미의 안정성을 선호한다.

---

패턴을 하나 deprecate 할 때, 페이스북 내부에서의 사용법을 스터디 하고

deprecate waraning을 붙인다.

그들은 우리가 변화의 영향을 평가하게 했다.

때로 우리는 우리가 발견한 것에서 일찍 손을 때기도 하고,

변화를 위해 이 코드베이스가 준비돼있는지 전략적으로 생각해볼 필요가 있었다.

변화가 지나치게 파괴적이적이지도 않고 마이그레이션 전략이 모든 실제 사례에서

실행 가능하다는 확신이 들면, 오픈소스 커뮤니티에 deprecation warning을 알린다.

우리는 페이스북 외부의 수많은 리액트 유저들과 긴밀하게 접촉한다.

그리고 유명한 오픈소스 프로젝트들을 모니터링하며 이러한 deprecation들을

그들이 고치도록 가이드한다.

---

페이스북의 리액트 코드 베이스 크기를 고려하면, 

성공적인 내부 마이그래이션은 종종 다른 회사들 사이에서도 문제가 없다는 좋은 지표가 된다.

그럼에도 불구하고, 가끔 사람들은 우리가 생각지 못한 추가 사례를 지적하고

우리는 그들을 위한 탈출 해치를 추가하거나 우리의 접근을 다시 생각해본다.

마땅한 이유 없이 어떠한 것도 deprecate 시키지 않는다.

때론 deprecation warning이 실망을 부른다는 것을 알고 있지만,

deprecation이 개선과 커뮤니티의 많은 사람들이 가치있다고 생각하는

새로운 기능을 위한 길을 깔끔하게 만든다.

예를들어 리액트 15.2.0에서 [`unknown DOM props warning`](https://reactjs.org/warnings/unknown-prop.html)을 추가했었다.

많은 프로젝트들이 이에 영향을 받았다. 하지만 이 경고를 고치는 것은 중요했고,

그렇게 리액트에 [`custom attributes`](https://github.com/facebook/react/issues/140)에 대한 지원을 소개할 수 있었다.

우리가 추가한 모든 deprecation 뒤에 이러한 이유가 있었다.

deprecation warning을 추가할 때, 남은 현재 메이저 버전에서 이를 

지속하고, 다음 메이저 버전에서 행동을 변경한다.

만약 반복적인 수작업이 많이 발생하면 대부분의 변경을 자동화한 

`codemod` 스크립트를 배포한다.

`Codemod`들은 우리가 덩치큰 코드베이스에서 지체없이 앞으로 갈 수 있도록 해주고

우리가 당신에게 그것들을 잘 사용할수 있게 독려할 수있게 해준다.

[react-codemod](https://github.com/reactjs/react-codemod)저장소에서 우리가 배포한 codemod들을 볼 수 있다.

## Interoperability(정보 처리 상호 운용)

우리는 기존 시스템과의 상호 운용성과 점진적 채택에 가치를 두고 있다.

페이스북은 거대한 비-리액트에 코드베이스를 갖고 있다.

페이스북 웹사이트는 XHP라 부르는 서버사이드 컴포넌트 시스템, 리액트 이전의 내부 UI 라이븝러리들 그리고 리액트를 혼용하고있다.

어떤 프로덕트 팀이라도 리액트로 코드를 엎는 대신 [작은 기능을 리액트로 시작](https://www.youtube.com/watch?v=BF58ZJ1ZQxY)할 수 있는게  중요하다.

이는 리액트가 가변적인 모델로 작업하기위한 탈출구를 제공하고 다른 UI라이브러리와 함께 잘 작동하려하는 이유다.

기존의 명령형 UI를 선언적 컴포넌트로 래핑하거나 그 반대로 할 수 있다.

이것이 점진적 채택에 결정적 이유다.


## Scheduling

리액트를 사용할 때 컴포넌트가 함수로 서술되더라도 당신은 그것들을 직접 호출하지 않는다.

모든 컴포넌트는 무엇이 렌더링 되어야하는지에 관한 명세를 리턴하고,

그 명세는 사용자가 작성한 `<LikeButton>`과 `<div>`같은 플랫폼-특화 컴포넌트 모두를 포함할 수 있다.

이는 리액트가 미래의 어떤 시점에 `<LikeButton>`를 "펼쳐"낼지 그리고 실제로 컴포넌트를

반복적으로 렌더링한 결과에 따른 UI트리 변경을 적용할지에 달렸다.

이는 미묘한 차이지만 강력한 것이다.

당신이 컴포넌트 함수를 호출하지 않고 리액트가 호출하도록하기 때문에,

리액트는 필요하다면 스스로 함수 호출을 지연시킬 수 있음을 의미한다.

현재 구현에서 리액트는 트리를 반복적으로 탐색하고 

한번의 틱동안 전체 업데이트된 트리의 렌더 함수를 호출한다.

하지만 앞으로 [프레임이 저하되지 않도록 일부 업데이트가 지연](https://github.com/facebook/react/issues/6170)될수 있다.

---

이것이 리액트 디자인에서 일반적인 테마다. 몇몇 유명한 라이브러리들은

새로운 데이터를 사용할 수 있을 때 계산이 수행되는 "push" 방식을 구현했다.

그러나, 리액트는 필요할 때까지 연산이 지연될 수 있는 "pull" 방식에 의존한다.

리액트는 일반적인 데이터 프로세싱 라이브러리가 아니라 유저 인터페이스를 만들기위한 라이브러리다.

우리는 앱에서 현재 어떤 계산이 관련성이 있고 그렇지 않은지 알 수 있는 유니크한 위치에 있다 생각한다.

---

어떤것이 스크린에 그려지지 않을때 우리는 그와 관련된 어떠한 로직이든 지연시킬 수 있다.

데이터가 프레임 속도보다 빨리 도착한다면 병합 및 일괄 업데이트가 가능하다.

프레임 저하를 피하기 위해 덜 중요한 백그라운드 작업(예 : 네트우크에서 롣된 새로운 콘텐트 렌더링)

같은것과 유저로 부터의 인터랙션들(버튼클릭 애니메이션같은) 사이에서 우선순위를 부여할 수 있다.

명확함을 위해 이에대한 이점을 지금 바로 말하지 않겠다.

그러나 이러한 걸 할 수 있는 자유는 우리가 스케쥴링 제어를 선호하고,

`setState()`가 비동기적인 이유다.

개념적으로 우리는 이걸 "스케쥴링 업데이트"로 생각한다.

[Functional Reactive Programming](https://en.wikipedia.org/wiki/Functional_reactive_programming)의 일부 변형에서 일반적인 "push" 기반 패러다임을 사용하여

유저가 직접 뷰를 작성하게 되면 스케쥴링 제어가 어려워진다.

우리만의 "접착제" 코드를 원했다.

리액트의 핵심 목표는 리액트로 되돌아가기 전에 실행되는 사용자 코드의 양이 최소화되는 것이다.

이는 리액트가 UI에대해 알고 있는 것에 따라 청크로 작업을 스케쥴하고 나누는 능력을 유지토록 한다.

여기 팀 내부적인 농담이 있다.

> 리액트는 "스케쥴"이라 불러야한다. 왜냐하면 리액트는 완전히 "reactive(반응적)"이고 싶지 않기 때문이다.


## Developer Experience

좋은 개발자 경험을 제공하는 것 또한 우리에게 중요하다.

현재 [React DevTools](https://github.com/facebook/react-devtools)를 메인테이닝 하고 있다.

우리는 이것이 페이스북 엔지니어와 커뮤니티에 큰 생산성을 가져다 주는것을 들었다.


우린 또한 도움이되는 개발자 경고를 제공하기 위해 추가 마일을 시도한다.

예를들어 개발중 브라우저가 이해할 수없는 태그를 중첩하거나 API에서 오타를 만들면 경고한다.

개발자 경고와 관련 확인사항은 리액트의 개발버전이 프로덕트 버전보다 느린 주된 이유다.

---

페북에서 내부적으로 보이는 사용 패턴은 일반적인 실수가 무엇인지 이해하고, 이를 조기에 방지하는 방을 알려준다.

새로운 기능을 추가할때, 우리는 일반적인 실수와 그에관한 경고를 예상하려 노력한다.

우린 항상 개발자 경험을 향상시키기 위한 방법을 찾고있다.


## Debugging

무언가가 잘못되었을 때, 코드에서 실수를 추적 할 수있는 빵 부스러기가 있어야하고,

state and props를 빵 부스러기로 사용한다.

리액트 개발도구를 열어 렌더링되야할 컴포넌트의 state와 props가 옳바른지 체크하고

아니라면 렌더함수 안에서 문제가 일어났거나 혹은 렌더함수에서 호출한 함수가 문제를 일으킴을 알수 있다.

문제는 분리돼있다.

state가 문제라면 하나의 `setState()`가 문제임을 알수 있다.

props가 문제라면 인스펙터에서 트리를 따라 올라가 옳지 않은 props가 내려온 첫번째 "오염된 우물" 컴포넌트를 찾을 수 있다.

현재 props와 state의 형태로 UI를 생성한 데이터를 추적하는 능력은 리액트에게 중요하다.

클로저와 콤비네이터에서 state가 "갇혀"있지 않고 리액트에서 직접 사용할 수 있는 것은

분명한 설계 목표다.

---

UI가 동적인 동안 우리는 props와 state의 동기적인 render()함수가 추측이 아닌 지루하더라도

유한한 절차로 디버깅을 전환했고 생각한다.

복잡한 애니메이션 사례에선 디버깅을 어렵게 하더라도 이러한 제약을 유지하려한다.


## Configuration

전역 런타임 설정 옵션이 문제가 많음을 발견했다.

예를 들어 `React.configure(options)` or `React.register(component)`같은 

함수를 만들어 달라는 요청을 받는다.

하지만 이는 여러 문제를 일으키고, 우린 마땅한 해결책이 없다.

서드파티 컴포넌트 라이브러리에서 그러한 함수를 호출한다면?

하나의 리액트 앱이 다른 리액트 앱에 임베드 되고 서로 상호 성립되지 않는 설정을 요구한다면?

서드파티 컴포넌트가 특정한 설정만을 필요로 한다면?

전역 설정은 조립과 잘 작동하지 않을 것이다.

조립은 리액트 중심적이기 때문에 우린 전역 설정을 제공하지 않을것이다.

그러나, 빌드 레벨에서 전역 설정을 제공하긴 한다.

개발과 프로덕션 빌드를 분리한다.

어쩌면 [프로파일링 빌드](https://github.com/facebook/react/issues/6627)를 추가할 수도 있으며, 다른 빌드 플래그를 고려할 수도 있다.


## Beyond the DOM

React의 가치는 버그가 적은 컴포넌트를 작성하고 함께 구성하는 방식으로 볼 수 있다.

DOM은 본래 리액트의 렌더링 타겟이지만, `React Native`는 페북과 커뮤니티 모두에게 중요하다.


렌더러에 의존하지 않는 것은 React의 중요한 디자인 제약이다.

이는 내부적 표현에 약간의 오버헤드를 가한다.

반면에 코어에 대한 개선 사항은 모든 플랫폼에서 번역된다.

단일 프로그래밍 모델을 사용하면 플랫폼 대신 제품 주위에 엔지니어링 팀을 구성 할 수 있다.

지금까지 우리에게는 그만한 가치가있었다.


## Implementation

우리는 구현의 우아함에 신경쓰는 대신 최대한 우아한 API들을 제공하려 노력했다.

실제로 완벽함과 거리가 멀다. 합당한 범위에서 우리는 사용자가 작성하지 않아도 된다는 것을 의미하는 

추한 코드를 라이브러리에 넣는 것을 선호한다.(_주: 심한 직역..._)

새로운 코드를 평가할 때, 구현이 올바른지 좋은 개발자 경험에 일조하는지를 본다.

우아함은 두번째다.

우리는 지루한 코드를 영리한 코드를 선호한다.(??) 

코드는 자주 바뀌고 버릴수도 있다. 

따라서 [절대적으로 필요하지 않는 한 새로운 내부 추상화를 도입하지 않는 것](https://www.youtube.com/watch?v=4anAwXYqLG8&feature=youtu.be&t=13m9s)이 중요하다.

곧 추상화되고 변경하기 어려운 우아한 코드보다 이동, 변경 및 제거가 쉬운 장황한 코드가 더 좋다.


## Optimized for Tooling

`componentDidMount()`라는 장황한 이름의 API가 있다. 이는 의도적이다.

라이브러리와 인터랙션 지점을 보다 분명히 하기 위함이다.

수많은 코드 속에서 기능에 차별화된 장황한 이름을 선호한다. 주의해서 써야할 기능에선 더욱 그렇다.

탐색을 위한 최적화도 중요한데, 이는 코드를 쪼개는 [codemods](https://www.youtube.com/watch?v=d0pOgY8__JM)에대한 의존 때문이다.

우리는 코드베이스 전반에 걸처 방대한 변경을 자동화하고 유니크하고 장황항 이름을 통해 이모든 것을 안전하고 쉽게 적용하려 한다. 

뚜렷한 이름은 잠재적인 오탐지에 대한 걱정 없이 리액트를 사용함에 있어 커스텀 [린트 룰](https://github.com/yannickcr/eslint-plugin-react)을 작성하기 쉽게해준다.

JSX도 비슷한 역할을 한다. 필수 요구사항은 아니지만 미적, 실용적이유로 페북에서 광범위하게 사용한다.

우리의 코드베이스에서, JSX는 리액트 엘리먼트 트리를 다루는 도구들에게 명백한 힌트를 제공한다.

이를 통해 상수 엘리먼트를 끌어 올리거나, 안전한 lint, `codemod`내부 컴포넌트 사용법,

경고에 JSX 소스 위치를 포함시키는 등의 빌드 타임 최적화를 추가 할 수 있다. 


## Dogfooding

우리는 커뮤니티에서 제기된 문제들을 풀기위해 최선을 다한다.

그러나 우리는 사람들이 페북에서 내부적으로 겪고있는 문제의 우선 순위를 결정할 가능성이 크다.

어쩌면 반-직관적으로 이것이 커뮤니티가 리액트에 확신을 거는 주된 이유라고 생각한다.

폭넓은 내부 사용은 리액트가 내일 당장 사라지지않을 것이라는 확신을 준다.

리액트는 페이스북의 문제를 풀기 위해 만들어졌다.

이는 가시적 비지니스 가치를 회사에 제공하며 수많은 프로덕트에 사용된다.

"개밥 먹기"는 우리의 비젼을 날서있도록 해주며 우리가 가려는 방향에 집중하게 해준다.

그렇다고 해서 우리가 커뮤니티에서 제기된 문제를 무시한다는 뜻은 아니다.

실제로 우리 내부적으로는 관련없는 [웹 컴포넌트](https://reactjs.org/docs/web-components.html)와 [SVG](https://github.com/facebook/react/pull/6243) 지원을 추가했다.

우리는 여러분의 [아픈점을 경청](https://github.com/facebook/react/issues/2686)하고 [해결하기 위해](https://reactjs.org/blog/2016/07/11/introducing-reacts-error-code-system.html) 노력을 다하고 있다.

커뮤니티는 리액트를 우리에게 틀별하게 만드는 요소이며, 이에 기여할 수 있어 영광이다.

---

페이스북에서 수 많은 오픈소스 프로젝트를 발표한 후, 깨달은 것은

모두를 동시에 만족시킬 수 없다는 것이다. 오히려 이는 프로젝트가 성장하는 걸 방해한다.

그대신 적은 청중을 찾아 그들을 행복하게 하는데 집중하면 긍정적인 넷 효과를 가져온다는 걸 발견했다.

리액트가 진정 그런 것이다. 페이스북이 직면한 문제를 해결한 것이 오픈 소스 커뮤니티에 잘 전달됐다.

이런 방식의 단점은 페이스북 팀이 "Getting Started" 체험 처럼 때떄로

충분히 주의를 기울이지 못한다는 것이다. 이러한 점을 우리는 잘 알고 있으며

이전 오픈소스 프로젝트와 동일한 실수를 저지르지 않으면서 커뮤니티 사람들 모두에게

도움이 될수 있는 개선법을 생각하고 있다.
