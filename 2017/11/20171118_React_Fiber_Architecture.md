# React Fiber Architecture

### 사전 지식

아래 글을 읽어보길 **강력하게 권장**한다.

1. [React Component, Elements and Instances](https://reactjs.org/blog/2015/12/18/react-components-elements-and-instances.html) - "Component"는 자주 여러번 사용된다. 이 용어를 정확히 파악해야한다. _[(번역보기)](https://github.com/goohooh/TIL/blob/master/2017/11/20171111_React_Components_Elements_Instances.md)_

1. [Reconciliation](https://reactjs.org/docs/reconciliation.html) - 고수준의 리액트 reconciliation 알고리즘 명세 _[(번역보기)](https://github.com/goohooh/TIL/blob/master/2017/11/20171109_React_Reconciliation.md)_

1. [React Basic Theoretical Conceps](https://github.com/reactjs/react-basic) - 리액트의 개념 모델 상세 _[(번역보기)](https://github.com/goohooh/TIL/blob/master/2017/11/20171112_React_Basic_Theoretical_Concepts.md)_

1. [React Design Principles](https://reactjs.org/docs/design-principles.html) - "Scheduling" 섹션을 주의 깊게 일어 보라. 왜 리액트 Fiber인지 잘 설명해준다. _[(번역보기)](https://github.com/goohooh/TIL/blob/master/2017/11/20171117_React_Design_Principles.md)_


## Review

몇가지 컨셉을 리뷰해보자.

#### reconciliation이란?

<dl>
	<dt>reconciliation</dt>
	<dd>리액트에서 하나의 트리와 다른 하나의 트리의 차이별로 변경해야할 부분을 결정하는 알고리즘.</dd>
</dl>

<dl>
	<dt>update</dt>
	<dd>리액트 앱을 그릴때 사용되는 데이터의 변경. 일반적으로 `setState`의 결과. 결과적으로 다시 렌더링함.</dd>
</dl>

리액트 API의 핵심 아이디어는 업데이트를 전체 앱이 다시 렌더링 되는 것으로 여기는 것이다.
이는 개발자가 어떻게 하면 어플리케이션에서	어떠한 특정 state에서 또다른 state로의 변경이 효율적으로 일어나게할지 고민 하기 보다 선언적으로 추론할 수 있게 해준다. 

실제로 매 변경마다 전체 앱을 다시 그리는 것은 평범한 앱에서만 효과적이다.
실제 앱들에서는 성능에 엄청난 비용을 치루어야 한다.
리액트는 성능을 유지하면서 전체 앱들 다시 그리는 모습을 만드는 최적화 기능을 가지고 있다.
이런 다량의 최적화는 **reconciliation**이라 불리는 프로세스의 일부다.

Reconciliation은 널리 알려진 "버추얼 DOM" 뒤에서 동작하는 알고리즘이다.
고 수준 명세에는 이와같이 설명한다: 리액트 어플리케이션을 렌더링할 때,
앱을 설명하는 노드들의 트리가 생성되고 메모리에 저장된다. 이 트리는 렌더링 환경으로 넘어간다. 브라우저 어플리케이션을 예로 들어, 이는 곧 일련의 DOM 작업으로 변환된다. 앱이 업데이트되고(일반적으로 `setState`에 의해), 새로운 트리가 만들어진다. 이 새로운 트리는 이전 트리와 구분되어 렌더링 된 앱을 업데이트하는 데 필요한 작업을 계산한다.

비록 Fiber가 reconciler을 갈아 엎지만, 리액트 문서에 설명된 고 수준의 알고리즘은 대체로 동일하다. 키포인트는:

 - 다른 컴포넌트 타입은 대체로 다른 트리들을 생성한다고 가정한다. 리액트는 그들을 분별하지 않지만, 예전 트리를 완전히 대체한다.

 - 목록들의 Diffing은 키를 가지고 수행된다. 키는 반드시 "안정적이고 예측가능하며 독자적"이어야 한다.

#### Reconciliation versus rendering

DOM은 그저 리액트가 그릴수 있는 렌더링 환경 중 하나일 뿐이며, 다른 대상으로는 리액트 네이브를 통한 기본 iOS 및 안드로이드 뷰가 있다. ("버추얼 DOM"는 약간 잘못된 이름이다)

이처럼 다양한 대상을 지원할 수 있는 이유는 리액트가 reconciliation과 렌더링이 분리된 단계로 디자인 됐기 때문이다. reconciler는 트리의 어느 부분이 변경됐는지 계산하는 작업을 수행한다. 그리고나면 렌더러는 해당 정보를 이용하여 실제로 렌더링된 앱을 업데이트 한다.

이러한 분리 체계는 리액트 코어가 제공하는 같은 reconciler를 공유하며 React DOM과 React Native가 그들만의 렌더러를 사용할 수 있음을 의미한다.

Fiber는 reconciler를 재구현하는 것이다. 비록 렌더러가 새로운 아키텍처를 지원(및 활용)하기 위해 변경되야 하지만, 렌더링에 관련된 것은 아니다.

#### Scheduling

<dl>
	<dt>scheduling</dt>
	<dd>작업 수행시기를 결정하는 프로세스</dd>
</dl>

<dl>
	<dt>work</dt>
	<dd>어떠한 계산도 수행되어야 함. 작업은 일반적으로 업데이트의 결과임(예: `setState`)</dd>
</dl>

리액트의 디자인 원칙 문서에는 이 주제가 잘 설명돼있다. 키포인트는:

 - UI에서, 모든 업데이트가 즉시 적용되는건 중요치 않다; 사실 그러한 동작은 불필요하다, 프레임저하를 일으키고 사용자 경험을 저해한다.

 - 다른 유형의 업데이트는 다른 중요도를 가진다: 에니메이션 업데이트는, 예를 들어 저장소의 업데이트보다 빨리 완료되어야 한다.

 - 푸시-기반 접근법은 어떻게 작업을 계획해야할지 (당신, 프로그래머)에게 요구한다. 풀-기반 접근법은 당신을 위해 이러한 결정을 프레임워크(리액트)가 똑똑하게 처리하도록 허용한다.

리액트는 현재 중요한 방식으로써 스케쥴링을 활용하지 않고있다; 모든 서브 트리의 업데이트 결과는 즉시 리렌더링 된다. 스케쥴링의 이점을 얻기위해 리액트의 코어 알고리즘을 손보는 것은 곧 Fiber의 원동력이다.

---

이제 Fiber의 구현으로 넘어갈 준비가 됬다. 다음 섹션은 우리가 논의 했던것들 보다 좀더 기술적이다. 

## Fiber란?

우린 리액트 Fiber의 아키텍처에 관해 논의하고 있다. Fiber는 어플리케이션 개발자가 전형적으로 생각하는 것 이상으로 lower-level의 추상화다. 이를 이해하려는데 어려움을 느낀다 해도, 실망하지 않아도 된다. 계속 시도하면 결국 알아낼 수 있다.(그런날이 온다면, 이 섹션을 어떻게 개선할지 제안해주면 고맙겠다)

ㄱㄱ

---

이전에 Fiber의 핵심 목표가 스케쥴링의 이점을 얻는 것이라 확인했다. 구체적으로 우리는:

- 작업을 멈추가 나중에 다시 돌아와야 한다.
- 다른 유형의 작업에 중요도를 할당한다.
- 이전에 완료된 작업을 재사용한다.
- 더이상 필요하지 않은 작업은 중단한다.

이를 위해 우리는 먼저 작업을 단위로 쪼개는 방법이 필요하다. 한 가지 의미로, 그것이 Fiber(섬유)다. Fiber는 작업 단위를 나타낸다.

더 나아가기 위해, [React component as functions of data](https://github.com/reactjs/react-basic#transformation) 개념을 돌아가본다. 

	v = f(d)

리액트 앱을 렌더링하면 본문에서 다른 함수를 호출하는 등을 포함해 함수를 호출하는 것과 비슷하다. 이러한 유사성은 fiber에 관해 생각해볼때 유용한다.

전형적으로 컴퓨터가 프로그램 실행을 추적하는 방식은 콜 스택이다. 함수를 실행하면, 새로운 스택 프레임이 스택에 추가된다. 그 스택 프레임은 함수에 의해 실행되는 작업을 나타낸다.

UI를 다룰 때 문제는 한번에 실행할 작업이 너무 많다는 것이다. 이는 애니메이션 프레임저하나 보기 조잡해보이는 이유가 된다. 게다가, 일부 작업은 최근에 업데이트된 것으로 대체됨으로 인해 불필요해 질 수도 있다. 여기서 UI 컴포넌트들과 함수의 비교가 의미 없어 진다. 컴포넌트는 일반적인 함수에 비해 상세한 고려 사항이 많기 때문이다.
