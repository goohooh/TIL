k# How JavaScript works: memory management + how to handle 4 common memory leaks

> _원문 : [How Javascript works - 3](https://blog.sessionstack.com/how-javascript-works-memory-management-how-to-handle-4-common-memory-leaks-3f28b94cfbec)_

매일 기본으로 사용되는 프로그래밍 언어의 성숙도와 복잡성 증가로 인해 개발자들로 부터 방치된 메모리 운영에 관한 논의를 할 것이다.

## 개요

C 같은 low-level 언어는 `malloc()`과 `free()`같은 메모리 관리 원형 함수를 갖는다. 이러한 함수들은 개발자가 명시적으로 할당하고 운영 체제로부터 메모리를 헤재하는데 사용된다.

JS는 객체들, 문자열 등등의 것들이 만들어질 때 메모리 할당을 하고 _가비지 컬렉션_ 이라 불리는 프로세스를 통해 "자동으로" 더이상 사용되지 않는 것들을 메모리 해제한다.

**리소스를 확보하는 것처럼 보이는 겉보기에 "자동적인" 특성은 혼란을 야기하며 JS나 여타 high-level 언어 개발자들에게 메모리관리를 신경쓰지 않아도 되는 것처럼 잘못된 인상을 줄 수 있다.**

**이는 매우큰 실수다.**

고수준 언어를 사용하더라도 개발자는 메모리 운영(최소한 기본정도는)에 관한 이해를 가져야 한다. 간혹 개발자들이 자동 메모리 운영 이슈(버그나 가비지컬렉터의 구현 한계 등)같이 제대로 다루기 위해 이해해야할 이슈들이 있다.(혹은 최소한의 트레이드 오프나 코드 부채로 해결방법을 찾거나)

## 메모리 생명 주기

어떤 언어를 쓰든, 메모리 생명 주기는 거의 동일하다.

![Memory life cycle](https://cdn-images-1.medium.com/max/1600/1*slxXgq_TO38TgtoKpWa_jQ.png)

각 단계에 대한 개관을 보자.

- Allocate memory : 메모리는 당신의 프로그램이 이를 사용할 수 있도록 OS에 의해 할당된다. C 같은 저수준 언어에서 이는 개발자로서 조작해야하는 명시적인 연산이다. 그러나 고수준 언어에선 당신을 위해 이런 문제가 해결되어있다.

- Use memory : 당신의 프로그램이 이전에 할당된 메모리를 실제로 사용하는 시간이다. **읽기**와 **쓰기** 연산들은 당신의 코드에서 당신이 할당한 변수들을 이용함에 따라 이루어진다.

- Release memory : 이제 필요없어진 모든 메모리를 해제하는 시간이다. 이에 따라 메모리는 자유로워지고 다시 사용할수 있는 상태가 된다. **Allocate memory**작업과 마찬가지로 이 작업은 저수준 언어에서 명시적으로 드러나 있다.

콜스택과 메모리 힙에관한 컨셉 개관을 훓어보려면 우리의 [첫번쨰 포스트](https://blog.sessionstack.com/how-does-javascript-actually-work-part-1-b0bacc073cf) _([번역보기](https://github.com/goohooh/TIL/blob/master/2017/11/20171119_How_JavaScript_works_Overview.md))_ 를 읽어볼 수 있다. 

## 메모리란?

JS의 메모리로 바로 들어가기 전에, 일반적인 메모리가 무엇인지 어떻게 동작하는지 간략히 논의해본다.

하드웨어 레벨에서, 컴퓨터 메모리는 수많은 플립플랍[[위키](https://en.wikipedia.org/wiki/Flip-flop_(electronics)),[나무위키](https://namu.wiki/w/%ED%94%8C%EB%A6%BD%ED%94%8C%EB%A1%AD)]으로 구성돼있다. 각각의 플립플랍은 트랜지스터를 조금 포함하며, 하나의 비트만 저장할 수 있다. 개별 플립플랍들은 유니크한 식별자로 어드레스할 수 있으며 이를 읽고 덮어 쓸 수 있다.

인간이기 때문에, 우리는 비트로 사고하는 것과 산술하는 것에 그리 뛰어나지 않다. 그래서 그것들을 더 큰 그룹으로 구성하여 이를 표현하는 숫자로 이용할 수 있다. 8비트는 1바이트로 부른다. 바이트를 넘어선 단어도 있다.(때로 16비트, 32비트)

많은 것들이 메모리에 담겨있다.

1. 모든 프래그래들이 사용하는 모든 변수들과 다른 데이터

1. 운영체제를 포함한 프로그램들의 코드

컴파일러와 운영체제는 당신을 위해 대부분의 메모리 운영을 관리하기 위해 함께 동작한다. 하지만 당신이 이에관해 기저에서 일어나는 것들을 알아보길 추천한다.

당신의 코드를 컴파일 할때, 컴파일러는 원시 데이터 타입들을 살펴보고 그것들이 얼마나 메모리를 필요하는지 미리 계산할 수 있다. 필요한 양은 콜 **스택 공간**의 프로그램에 할당된다. 변수들이 할당돼는 공간은 함수가 호출될 때, 그것들의 메모리가 기존 메모리 위에 추가되기 때문에 **스택 스페이스**라고 불린다. 종료될 때는 LIFO(후입선출) 순으로 제거 된다. 다음 선언을 보면:

```c
int n; // 4 bytes
int x[4] // array of 4 elements, each 4 bytes
double m; // 8 bytes
```

컴파일러는 코드에서 필요한 것을 찾아낸다

4 + 4 * 4 + 8 = 28 bytes

> int와 더블의 현재 사이즈를 어떻게 다루는지 보여준다. 20년 전, int는 일반적으로 2바이트, double은 4바이트 였다. 당신의 코드는 지금 순간의 기본 데이터 타입의 사이즈가 무엇인지에 의존해선 안된다.

컴파일러는 당신의 변수들이 저장되기 위해 스택에서 필요한 바이트 숫자를 요청할 목적으로 운영체제와 상호작용하는 코드를 삽입한다.

위 예제에서, 컴파일러는 각 변수의 정확한 메모리 주소값을 알고있다. 사실 변수 `n`을 write할 때마다, 이는 내부적으로 "메모리 주소 4127963"같은 것으로 변환된다.

`x[4]`에 접근하려 한다면, m과 관련된 데이터에 접근했을 것이다. 왜냐하면 우리가 존재하지 않는 배열에 접근했기 때문이다: 이는 배열에서 x[3]으로 마지막 실제 할당된 요소보다 4바이트 많아지고 m의 비트일부 비트를 읽거나 덮어 쓸 수 있게된다. 이는 나머지 프로그램에 매우 의도치 않은 결과를 초래할 것이다.

![memory](https://cdn-images-1.medium.com/max/1600/1*5aBou4onl1B8xlgwoGTDOg.png)

함수들이 다른 함수들을 부를 때, 각각은 호출될 때 스택의 자체 청크를 얻는다. 여기선 각각의 지역변수들을 가지고있지만, 함수가 실행되는 장소를 기억하는 프로그램 카운터도 있다. 함수가 끝나면, 이 메모리 블럭은 다른 수행을 목적으로 다시 사용가능하게 만들어진다.

## 동적 할당

하지만 변수가 얼마나 메모리를 사용할지 컴파일 타임에서 모르는 경우는 쉽지가 않다. 다음 상황에서:

```c
int n = readInput(); // 사용자로 부터 입력받고 읽음

...

// n 요소로 이루어진 배열을 만듦
```

컴파일 시간에, 컴파일러는 유저에 의해 입력되는 값에 따라 배열의 메모리 사용량이 결정되기 때문에 얼마나 메모리를 사용할지 알 수 없다.

따라서 스택에 변수를 위한 공간을 할당할 수 없다. 대신 우리 프로그램은 런타임에 운영체제에게 적절한 양의 공간을 확실히 요구해야한다. 이 메모리는 **heap space**에서 할당된다. 정적할당과 동적할당의 차이를 아래 테이블에 요약했다.

| 정적 할당 | 동적 할당 |
|---|---|
| 컴파일 타임에 사이즈를 알 수 있음 | 컴파일 타임에 사이즈를 모를 수도 있음 |
| 커파일 타임에 수행됨 | 런타임에 수행됨 |
| 스택에 할당됨 | 힙에 할당됨 |
| 선입후출 | 특별한 순서가 없음 |

동적 할당이 어떻게 이뤄지는지 더 알기 위해, **포인터**에 시간을 할애해야 한다. 하지만 이번 토픽에서 다루기엔 너무 큰 주제이다. 더 알고 싶다면 코멘트를 통해 알려달라. 다음 포스트에서 포인터에 다뤄보도록 하겠다.