k# How JavaScript works: memory management + how to handle 4 common memory leaks

> _원문 : [How Javascript works - 3](https://blog.sessionstack.com/how-javascript-works-memory-management-how-to-handle-4-common-memory-leaks-3f28b94cfbec)_

매일 기본으로 사용되는 프로그래밍 언어의 성숙도와 복잡성 증가로 인해 개발자들로 부터 방치된 메모리 운영에 관한 논의를 할 것이다.

## 개요

C 같은 low-level 언어는 `malloc()`과 `free()`같은 메모리 관리 원형 함수를 갖는다. 이러한 함수들은 개발자가 명시적으로 할당하고 운영 체제로부터 메모리를 헤재하는데 사용된다.

JS는 객체들, 문자열 등등의 것들이 만들어질 때 메모리 할당을 하고 _가비지 컬렉션_ 이라 불리는 프로세스를 통해 "자동으로" 더이상 사용되지 않는 것들을 메모리 해제한다.

**리소스를 확보하는 것처럼 보이는 겉보기에 "자동적인" 특성은 혼란을 야기하며 JS나 여타 high-level 언어 개발자들에게 메모리관리를 신경쓰지 않아도 되는 것처럼 잘못된 인상을 줄 수 있다.**

**이는 매우큰 실수다.**

고수준 언어를 사용하더라도 개발자는 메모리 운영(최소한 기본정도는)에 관한 이해를 가져야 한다. 간혹 개발자들이 자동 메모리 운영 이슈(버그나 가비지컬렉터의 구현 한계 등)같이 제대로 다루기 위해 이해해야할 이슈들이 있다.(혹은 최소한의 트레이드 오프나 코드 부채로 해결방법을 찾거나)

## 메모리 생명 주기

어떤 언어를 쓰든, 메모리 생명 주기는 거의 동일하다.

![Memory life cycle](https://cdn-images-1.medium.com/max/1600/1*slxXgq_TO38TgtoKpWa_jQ.png)

각 단계에 대한 개관을 보자.

- Allocate memory : 메모리는 당신의 프로그램이 이를 사용할 수 있도록 OS에 의해 할당된다. C 같은 저수준 언어에서 이는 개발자로서 조작해야하는 명시적인 연산이다. 그러나 고수준 언어에선 당신을 위해 이런 문제가 해결되어있다.

- Use memory : 당신의 프로그램이 이전에 할당된 메모리를 실제로 사용하는 시간이다. **읽기**와 **쓰기** 연산들은 당신의 코드에서 당신이 할당한 변수들을 이용함에 따라 이루어진다.

- Release memory : 이제 필요없어진 모든 메모리를 해제하는 시간이다. 이에 따라 메모리는 자유로워지고 다시 사용할수 있는 상태가 된다. **Allocate memory**작업과 마찬가지로 이 작업은 저수준 언어에서 명시적으로 드러나 있다.

콜스택과 메모리 힙에관한 컨셉 개관을 훓어보려면 우리의 [첫번쨰 포스트](https://blog.sessionstack.com/how-does-javascript-actually-work-part-1-b0bacc073cf) _([번역보기](https://github.com/goohooh/TIL/blob/master/2017/11/20171119_How_JavaScript_works_Overview.md))_ 를 읽어볼 수 있다. 

## 메모리란?

JS의 메모리로 바로 들어가기 전에, 일반적인 메모리가 무엇인지 어떻게 동작하는지 간략히 논의해본다.

하드웨어 레벨에서, 컴퓨터 메모리는 수많은 플립플랍[[위키](https://en.wikipedia.org/wiki/Flip-flop_(electronics)),[나무위키](https://namu.wiki/w/%ED%94%8C%EB%A6%BD%ED%94%8C%EB%A1%AD)]으로 구성돼있다. 각각의 플립플랍은 트랜지스터를 조금 포함하며, 하나의 비트만 저장할 수 있다. 개별 플립플랍들은 유니크한 식별자로 어드레스할 수 있으며 이를 읽고 덮어 쓸 수 있다.

인간이기 때문에, 우리는 비트로 사고하는 것과 산술하는 것에 그리 뛰어나지 않다. 그래서 그것들을 더 큰 그룹으로 구성하여 이를 표현하는 숫자로 이용할 수 있다. 8비트는 1바이트로 부른다. 바이트를 넘어선 단어도 있다.(때로 16비트, 32비트)

많은 것들이 메모리에 담겨있다.

1. 모든 프래그래들이 사용하는 모든 변수들과 다른 데이터

1. 운영체제를 포함한 프로그램들의 코드

컴파일러와 운영체제는 당신을 위해 대부분의 메모리 운영을 관리하기 위해 함께 동작한다. 하지만 당신이 이에관해 기저에서 일어나는 것들을 알아보길 추천한다.

당신의 코드를 컴파일 할때, 컴파일러는 원시 데이터 타입들을 살펴보고 그것들이 얼마나 메모리를 필요하는지 미리 계산할 수 있다. 필요한 양은 콜 **스택 공간**의 프로그램에 할당된다. 변수들이 할당돼는 공간은 함수가 호출될 때, 그것들의 메모리가 기존 메모리 위에 추가되기 때문에 **스택 스페이스**라고 불린다. 종료될 때는 LIFO(후입선출) 순으로 제거 된다. 다음 선언을 보면:

```c
int n; // 4 bytes
int x[4] // array of 4 elements, each 4 bytes
double m; // 8 bytes
```

컴파일러는 코드에서 필요한 것을 찾아낸다

4 + 4 * 4 + 8 = 28 bytes

> int와 더블의 현재 사이즈를 어떻게 다루는지 보여준다. 20년 전, int는 일반적으로 2바이트, double은 4바이트 였다. 당신의 코드는 지금 순간의 기본 데이터 타입의 사이즈가 무엇인지에 의존해선 안된다.

컴파일러는 당신의 변수들이 저장되기 위해 스택에서 필요한 바이트 숫자를 요청할 목적으로 운영체제와 상호작용하는 코드를 삽입한다.

위 예제에서, 컴파일러는 각 변수의 정확한 메모리 주소값을 알고있다. 사실 변수 `n`을 write할 때마다, 이는 내부적으로 "메모리 주소 4127963"같은 것으로 변환된다.

`x[4]`에 접근하려 한다면, m과 관련된 데이터에 접근했을 것이다. 왜냐하면 우리가 존재하지 않는 배열에 접근했기 때문이다: 이는 배열에서 x[3]으로 마지막 실제 할당된 요소보다 4바이트 많아지고 m의 비트일부 비트를 읽거나 덮어 쓸 수 있게된다. 이는 나머지 프로그램에 매우 의도치 않은 결과를 초래할 것이다.

![memory](https://cdn-images-1.medium.com/max/1600/1*5aBou4onl1B8xlgwoGTDOg.png)

함수들이 다른 함수들을 부를 때, 각각은 호출될 때 스택의 자체 청크를 얻는다. 여기선 각각의 지역변수들을 가지고있지만, 함수가 실행되는 장소를 기억하는 프로그램 카운터도 있다. 함수가 끝나면, 이 메모리 블럭은 다른 수행을 목적으로 다시 사용가능하게 만들어진다.

## 동적 할당

하지만 변수가 얼마나 메모리를 사용할지 컴파일 타임에서 모르는 경우는 쉽지가 않다. 다음 상황에서:

```c
int n = readInput(); // 사용자로 부터 입력받고 읽음

...

// n 요소로 이루어진 배열을 만듦
```

컴파일 시간에, 컴파일러는 유저에 의해 입력되는 값에 따라 배열의 메모리 사용량이 결정되기 때문에 얼마나 메모리를 사용할지 알 수 없다.

따라서 스택에 변수를 위한 공간을 할당할 수 없다. 대신 우리 프로그램은 런타임에 운영체제에게 적절한 양의 공간을 확실히 요구해야한다. 이 메모리는 **heap space**에서 할당된다. 정적할당과 동적할당의 차이를 아래 테이블에 요약했다.

| 정적 할당 | 동적 할당 |
|---|---|
| 컴파일 타임에 사이즈를 알 수 있음 | 컴파일 타임에 사이즈를 모를 수도 있음 |
| 커파일 타임에 수행됨 | 런타임에 수행됨 |
| 스택에 할당됨 | 힙에 할당됨 |
| 선입후출 | 특별한 순서가 없음 |

동적 할당이 어떻게 이뤄지는지 더 알기 위해, **포인터**에 시간을 할애해야 한다. 하지만 이번 토픽에서 다루기엔 너무 큰 주제이다. 더 알고 싶다면 코멘트를 통해 알려달라. 다음 포스트에서 포인터에 다뤄보도록 하겠다.

## JS의 할당

이제 JS의 메모리 할당으로 넘어간다.

JS는 개발자들을 메모리 할당 작업으로 부터 해방시켰다. 선업값들과 함께 JS 스스로가 처리한다.

```javascript
var n = 374 // 메모리에 숫자 할당
var s = 'sessionstack'; // 메모리에 문자열 할당

var o = {
	a: 1,
	b: null
} // 값들을 포함하는 객체를 메모리에 할당

var a = [1, null, 'str'] // (유사 객체) 값을 포함하는 배열을 메모리에 할당

function f(a) {
  return a + 3;
} // 함수 할당(호출할수 있는 객체)

// 마찬가지로 객체로 할당되는 함수표현
someElement.addEventListener('click', function() {
  someElement.style.backgroundColor = 'blue';
}, false);
```

일부 함수 호출은 객체 할당도 발생시킨다.

```javascript
var d = new Date(); // Date 객체 할당

var e = document.createElement('div'); // DOM 요소 할당 
```

메서드들은 새로운 값이나 객체를 할당할 수 있다.

```javascript
var s1 = 'sessionstack';
var s2 = s1.substr(0, 3); // s2는 새로운 문자열
// 문자열들은 불변이기 때문에,
// JS는 이를 메모리에 할당하지 않고,
// [0, 3] 범위만 저장하도록 결정할 수 있다.

var a1 = ['str1', 'str2'];
var a2 = ['str3', 'str4'];
var a3 = a1.concat(a2);
// 4개의 요소로 이루어진 새로운 배열은
// a1과 a2의 요소들로 연속된 것이다.
```

## JS의 메모리 사용

기본적으로 JS에서 할당된 메모리를 사용하는 것은 읽고 쓰는 것을 의미한다.

이는 읽거나, 변수의 값이나 객체의 프로퍼티를 쓰거나, 함수에 인자를 전달할때 수행될 수 있다.

## 더이상 메모리가 필요없을 때 해제하기

대부분의 메모리 운영 이슈는 이 단계에서 온다.

여기서 가장 힘든 작업은 언제 할당된 메모리가 더이상 필요없는지 알아내는 것이다. 이는 개발자가 프로그램에서 그러한 메모리 부분이 더이상 필요하지 않고 이를 해제하는 결정을 종종 요구한다.

고수준 언어에는 **가비지 컬렉터**라 불리는 일종의 소프트웨어가 내장돼있다. 메모리 할당을 추적하여 할당된 메모리가 더이상 필요하지 않을 때 메모리할당과 사용을 자동으로 해제한다.

불행히도 이러한 프로세스는 근사치일 뿐이다. 왜냐하면 어떤 메모리 조각이 필요한지 아닌지를 알아내는 문제는 쉽사리 결정할 수 없기 때문이다.(알고리즘으로 풀 수 없다)

대부분의 가비지 컬렉터는 더이상 접근할 수 없는 메모리를 수집하여 동작한다. 예: 메모리를 가리키고 있는 변수들이 스코프에서 사라지는 모든 경우. 그러나 이는 수집될 수 있는 메모리 공간들의 집합의 불충분한 추정치 집합이다. 왜냐하면 어떤 메모리 장소를 가리키건 이는 여전히 스코프에서 그곳을 가리키는 변수를 가질 수 있을 수도 있지만, 그럼에도 다시 그곳에 접솔할 수 없을것이다.

## 가비지 컬렉션

일부 메모리가 "더이상 필요하지" 아닌지 찾아내는것이 실제로 결정할수 없다는 사실때문에, 가비지 컬렉션은 일반적 문제의 해결첵을 제한적으로 구현했다. 현 섹션에서 메인 가비지 컬렉션의 알고리즘들과 그들의 한계를 이해하는데 필수적인 개졈들을 설명할 것이다.

## 메모리 참조

가비지 컬렉션 알고리즘의 주요 컨셉은 **참조**에 의존한다.

메모리 관리 컨텍스트 내에서 객체가 또다른 객체에 접근 할 수 있다면, 이를 참조하는것으로 간주할 수 있다.(암시적이든 명시적이든)

예를 들면, JS 객체는 자신의 [prototype](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Inheritance_and_the_prototype_chain)(**암시적 참조**)와 자신의 프로퍼티들의 값들(**명시적 참조**)를 가진다.

이 맥락에서 "객체"의 개념은 일반 JS 객체보다 좀더 광범위한 것으로 확장되고 함수 스코프 스코프도 포함한다(또는 글로벌 **렉시컬 스코프**).

>_렉시컬 스코핑은 변수이름이 중첩된 함수에서 어떻게 결정되는지 정의한다:_
 _부모함수가 리턴되더라도 부모함수의 스코프를 포함한 내부함수_

## 참조-집계 가비지 컬렉션

이는 가장 간단한 가비지 컬렉션 알고리즘이다. 객체를 가르키는 참조가 없는 경우 객체는 "garbage collectible"로 간주 된다.

아래 코드를 보면 :

```javascript
var o1 = {
	o2: {
		x: 1
	}
};

// 두개의 객체가 생성됐다.
// 'o2'는 'o1'객체의 하나의 프로퍼티로써 참조되어 있다.
// 아무것도 garbage-collectede 되지 않았다.

var o3 = o1; // 'o3'은 'o1'이 가리키는 객체를 참조하는 두번쨰 변수다.

o1 = 1; // 이제 'o1'이 원래 가리키던 객체는 'o3' 변수로 구체화된 단일 참조를 가진다.

// 객체의 'o2' 프로퍼티를 참조한다.
// 이 객체는 이제 2개의 참조를 갖는다: 하나는 프로퍼티로써, 다른 하나는 'o4' 변수로써.
var o4 = o3.o2;

// 이제 'o1'에 원래 있던 원래 객체를 참조하는 것은 아무것도 없다.
// 그것은 garbage-collected 될 수도 있다.
// 하지만 그 객체의 'o2'프로퍼티 였던 'o4' 변수에 의해 아직 참조되고 있다.
// 이제 이 객체는 해제될 수 없다.
o3 = '374'

// 원래 'o1' 객체의 'o2' 프로퍼티 였던 것을 참조하는 것이 아무것도 없다.
// 'o1'를 참조하는 것은 아무것도 없다.
// 이제서야 해당 객체는 garbage colleted 될 수 있다.
04 = null;
```

## 순환이 만드는 문제들

순환이 가져오는 제약이 있다. 다음 예시에서, 두 객체가 만들어 졌고 서로를 참조한다. 즉 순환이 만들어 졌다. 이들은 함수호출 후에 스코프를 벗어날 것이므로 쓸모없게 되고 해제해도 무방하다. 하지만 참조-집계 알고리즘은 각 객체들이 적어도 하나의 참조를 가지고 있게 되므로 둘다 garbage-collected 하지 않다고 판단한다.

```javascript
function f() {
	var o1 = {};
	var o2 = {};
	o1.p = o2; // o1이 o2를 참조
	o2.p = o1; // o2가 o1을 참조. 순환 생성
}
```

![creating cycle](https://cdn-images-1.medium.com/max/1600/1*GF3p99CQPZkX3UkgyVKSHw.png)

## Mark-and-sweep 알고리즘

객체가 필요한지 여부를 결정하기 위해, 이 알고리즘은 객체가 도달 가능한지 여부를 결정한다.

Mark-and-sweep 알고리즘은 아래 3단계를 거친다.

1. Root: 일반적으로, 루트는 코드에서 참조할 수 있는 전역 변수다. JS에서 보자면 `window`객체가 전역 변수인 루트로서 동작한다. Node.js에서 `global`이라 불리는 것과 동일하다. 모든 루트의 전체 목록은 가비지 컬렉터에서 작성된다.

1. 알고리즘은 이후 모든 루트와 그들의 자식들을 조사하고 가비지가 아니라는 뜻의'active'로써 그것들을 마크한다. 루트에서 도달하지 못하는 것은 가비지로서 마크된다.

1. 마지막으로, 가비지 컬렉터는 'active'로 마크되지 않은 모든 메모리 조각들을 해제하고 그 메모리를 운영체제에 반납한다.

![Mark and Sweep](https://cdn-images-1.medium.com/max/1600/1*WVtok3BV0NgU95mpxk9CNg.gif)

이 알고리즘은 "참조를 가지지 않은 객체"를 도달할 수 없다고 판단하기에 앞선 알고리즘보다 낫다. 순환에서 보았듯 그 반대는 사실이 아니다.

2012년대에 이르러서 모든 모던 웹 브라우져들은 mark-and-sweep 가비지 컬레터를 장착했다. 지난 몇 년간 자바스크립트 가비지 컬렉션의 모든 개선 사항은(generational/incremental/concurrent/parallel garbage collection) mark-and-sweep 알고리즘의 개선사항 일뿐, 가비지 컬렉션 알고리즘 자체를 넘어선 개선은 아니었다. 객체에 도달할 수 있는지 없는지를 결정하는 것도 그 목표는 아니었다.

[이 글에서](https://en.wikipedia.org/wiki/Tracing_garbage_collection) mark-and-sweep과 최적화를 다루는 가비지 컬렉션 추적에 대해 자세히 설명하고 있다.

## 순환은 더이상 문제가 아니다.

위 첫번째 예시에서, 함수가 리턴되고 난 이후 두 객체가 전역객체로 부터 더이상 참조 될 수 없다. 따라서 그들은 가비지 컬렉터에 의해 닿을 수 없는 것들로 받아들여진다,

![garbage collector](https://cdn-images-1.medium.com/max/1600/1*FbbOG9mcqWZtNajjDO6SaA.png)

비록 두 객체끼리 참조를 하고 있더라도, 그들은 루트로 부터 다다를 수 없는 곳에 있다.

## 반 직관적인 가비지 컬렉터들의 행동들

비록 가비지 컬렉터들이 편리하더라도 그들도 나름의 트레이드 오프를 가지고 있다. 그것들 중 하나가 비 결정성이다. 다른말로 하면, 가비지 컬렉터들은 예측할 수 없다. 당신은 언제 컬렉션이 수행될지 알 수 없다. 즉 몇몇 케이스에서 프로그램이 실제 필요한 것보다 더 많은 메모리를 사용할 수 있다는 것이다. 또 다른 경우, 특정 민감한 어플리케이션에서 짧은-일시정지 현상이 두드러지게 보일 수 있다. 비록 비결정성이 수행시기가 불분명할지라도, 대부분의 가비지 컬렉터 구현은 할당중에 컬렉션을 넘기는 공통적인 패턴을 공유한다. 만약 할당이 일어나지 않았다면, 대부분의 GC들은 아무것도 하지 않는다. 다음 시나리오을 고려해본다면:

1. 규모있는 세트의 할당이 수행됐다.

1. 대부분의 이런 요소(혹은 그들 전체)은 unreachable로 마크된다.(더 이상 필요없는 캐시를 가리키는 참조를 null로 가정한다)

1. 더 이상의 할당은 수행되지 않는다.

이 시나리오에서, 대부분의 GC들은 더 이상의 컬렉션 패스를 실행하지 않는다. 다른 말로, 컬렉션에 넣을 수 있는 unreachable한 참조들이 있더라도, 이것들은 컬렉터에 의해 문제가 제기되지 않는다. 이것들은 엄밀하게 누수는 아니지만 여전히 보통보다 높은 메모리 사용의 결과로 이어진다.

## 메모리 누수란 무엇인가.

메모리 제안처럼, 메모리 누수란 어플리케이션이 과거에 사용했지만 더이상 필요없어진 메모리를 OS나 메모리 풀에 반환하지 않은 메모리 조각들이다.

프로그래밍 언어들은 메모리 운영을 다양한 방식으로 조심스레 다룬다. 하지만 사용되거나 사용되지 않는 메모리 조각을 환신하는 것은 실제로 [결정할 수 없는 문제](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Memory_Management#Release_when_the_memory_is_not_needed_anymore)다. 달리 말하면, 오직 개발자만이 운영체제게 메모리를 반환할지 말지 명백하게 알 수 있다.

어떤 프로그래밍 언어들은 개발자가 이러한 일을 할 수 있도록 도와줄 기능들을 제공한다. 그외 언어들은 개발자가 언제 메모리를 사용하지 않는지 분명하게하길 기대한다. 위키피디아에서 [수동](https://en.wikipedia.org/wiki/Manual_memory_management)/[자동](https://en.wikipedia.org/wiki/Garbage_collection_%28computer_science%29) 메모리 운영에 관한 좋은 글을 볼 수 있다.

## 네가지 타입의 일반적 JavaScript 누수

### 1: 전역 변수

JS는 선언되지 않은 변수들을 흥미로운 방식으로 다룬다: 선언되지 않은 변수가 참조되면, 새 변수는 전역객체에 할당된다. 브라우저에서, 전역객체는 `window`일 것이다.

```javascript
function foo(arg) {
	bar = "some text";
}
```

이 코드는 아래와 동일하다.

```javascript
function foo(arg) {
	window.bar = "some text";
}
```

`bar`의 목적이 오직 foo 함수에서 참조하는 것이 목적이라 가정해본다. 선언을 위해 `var`를 사용하지 않은 결과 불필요한 전역 변수가 만들어졌다. 위의 경우, 별 피해를 입지 않을 것이다. 당신은 분명히 더 위험한 시나리오를 상상해볼 수 있다.

`this`의 사용으로 뜻하지 않게 전역 변수를 만들 수 있다:

```javascript
function foo(){
	this.var1 = "potential accidental global";
}

// foo함수를 함수 자체로 호출할 경우, this는 undefined를 가르키기 보다
// 전역 객체(window)를 가르킨다
foo();
```

> `'use strict';`를 자바스크립트 파일 첫 줄에 추가하여 이런 상황을 피할 수 있다. 이는 자바스크립트를 더욱 엄격한 모드로 파싱하여 예측할 수 없는 전역변수 생성을 막아준다.


예기치 않은 전역 변수는 확실히 문제다. 그러나 가비지 수집기에서 정의 할 수없는 명시 적 전역 변수가 코드에 포함되는 경우가 많다.(구글 번역...) 

대량의 정보를 임시적으로 저장하고 처리하는데 사용되는 전역변수에는 특별한 주의가 요구된다. 전역변수에 데이터를 저장하여 사용할 때, 사용을 완료한 후에 재할당이나 null할당을 권한다.

### 2: 잊혀진 타이머 혹은 콜백들

자바스크립트에서 자주 사용되는 `setInterval`의 예를 보자.

observer들과 콜백을 허용하는 다른 도구들을 제공하는 라이브러리들은 보통 콜백에 대한 모든 참조가 도달 할 수 없으면 그들의 인스턴스들도 도달할수 없도록 한다. 아래코드들 또한 어렵지 않게 찾아볼 수 있다.

```javascript
var serverData = loadData();
setInterval(function() {
	var renderer = document.getElementById('renderer');
	if(renderer){
		renderer.innerHTML = JSON.stringify(serverData);
	}
}, 5000); // 매 5초마다 실행
```

위 스니펫은 더이상 필요하지 않은 데이터나 노드를 참조하는 타이머를 사용했을때 나타나는 결과를 보여준다.

`renderer` 객체는 불필요한 인터벌 핸들러에 의해 인캡슐화 된 블록을 만드는 어떤 시점에 삭제되거나 대체될 수 있다. 이런 경우 인터벌을 먼저 중지해야 하므로(아직 할성화 됨) 핸들러 혹은 종속되는 것들이 수집되지 않는다.

이는 데이터를 저장하고 처리하는 serverData가 수집되지 않는다는 사실을 졸여버린다.(의역...)