# JavaScript Promise
> 한빛미디어 [리얼타임] JavaScript Promise

## 3. Promise 특징

### 3.1 항상 비동기로 처리되는 Promise

`Promise`는 추상화하는 로직이 동기적일지라도 항상 비동기로 처리된다.

```javascript
let = promise = new Promise(resolve => {
    console.log('inner promise');
    resolve(42);
});

promise.then(val => {
    console.log(val);
});

console.log('outer promise');

// inner promise
// outer promise
// 42
```

당연한 결과...

```javascript
function onReady(fn){
    var readyState = document.readyState;

    if(readyState === 'interactive' || readyState === 'complete'){
        fn();
    } else {
        window.addEventListener('DOMContentLoaded', fn);
    }
}

onReady(() => {
    console.log('DOM fully loaded and parsed');
});

console.log('====START====');
```

위 코드는 console에 찍히는 텍스트의 순서를 보장할 수 없다.

순서 보장을 위해 비동기 코드로 손을 보면

```javascript
if(readyState === 'interactive' || readyState === 'complete'){
    setTimeout(fn, 0);
}
```

> 데이비드 허먼의 "Effective JavaScript"에서 아래와 같이 설명한다고 한다.

- 데이터를 즉시 사용할 수 있더라도, 절대로 비동기 콜백을 동기적으로 호출하지 마라.

- 비동기 콜백을 동기적으로 호출하면 기대한 연산의 순서를 방해하고, 예상치 않은 코드의 간섭을 초래할 수 있다.

- 비동기 콜백을 동기적으로 호출하면 스택 오버플로우나 처리되지 않는 예외를 초래할 수 있다.

- 비동기 콜백을 다른 턴에 실행되도록 스케줄링하기 위해 `setTimeout` 같은 비동기 API를 사용하라.

항시 비동기로 처리되기 때문에 명시적으로 비동기 처리를 위한 코드를 추가로 작성할 필요가 없다.

```javascript
function onReadyPromise() {
    return new Promise((resolve, reject) => {
        let readyState = document.readyState;

        if(readyState === 'interactive' || readyState === 'complete'){
            resolve(); // 이미 비동기 수행
        } else {
            window.addEventListener('DOMContentLoaded', resolve);
        }
    });
}

onReadyPromise().then(() => {
    console.log('DOM fully loaded and parsed');
});

console.log('====START====');
```

### 3.2 새로운 promise 객체를 반환하는 then

`promise.then().catch()`는 언뜻 최초의 promise 객체를 체이닝하는 것처럼 보이지만

각각의 메서드는 새로운 promise 객체를 반환한다.

```javascript
var promise = new Promise(resolve => {
    resolve(100)
});
var thenPromise = promise.then(value => { 
    console.log(value)
});
var catchPromise = thenPromise.catch(error => {
    console.error(error)
});

console.log(promise === thenPromise); // false
console.log(thenPromise === catchPromise); // false
```
**항상 이 구조를 의식하고 개발 할 것!!**

```javascript
/*
 * then()으로 등록한 함수가 동시에 호출됨
 */
var aPromise = new Promise(resolve => {
    resovle(100);
});

aPromise.then(value => {
    return value * 2;
});

aPromise.then(value => {
    return value * 2;
});

aPromise.then(value => {
    console.log('1: ' + value); // 100
});

/*
 * then()으로 등록한 함수가
 * promise 체인의 순서대로 호출됨
 */
 var bPromise = new Promise(resolve => {
    resolve(100);
});

bPromise.then(value => {
    return value * 2;
}).then(value => {
    return value * 2;
}).then(value => {
    console.log('2: '+ value); // 400
});
```

`aPromise`는 체인으로 연결하지 않았다.

그걸과 `then()`에 등록된 각 콜백 함수는 동시에 호출되므로 `value`가 모두 100이다.

`bPromise`는 체이닝을 통해 value가 전달된다.(당연히 첫번째 방식은 안티패턴)

```javascript
function anAsyncCall() {
    let promise = Promise.resolve();

    promise.then(() => {
        // do something...

        return newVar;
    });

    return promise;
}
```

위 안티패턴처럼 작성하면 `then()`처리 중 어떤 오류가 발생했을 때 감지할 방법이 없다.

또한 특정 결과값을 반환하더라도 전달받을 수 없다.(newVar)

```javascript
function anAsyncCall() {
    let promise = Promise.resolve();

    return promise.then(() => {
        // do something...

        return newVar;
    });
}
```
