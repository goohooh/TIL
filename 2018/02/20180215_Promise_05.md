# JavaScript Promise
> 한빛미디어 [리얼타임] JavaScript Promise

## 5. Promise 고급

- 프로미스로 `Web Notification API` 다루기
- `throw` 대신 `reject`를 사용해야 하는 이유
- `Deffered`와 `Promise`의 관계
- 다양한 라이브러리

### 5.1 Promise 라이브러리

#### 폴리필

- [es6-promise](https://github.com/stefanpenner/es6-promise) : `Promise/A+` 스펙을 호환하는 RSVP.js 기반의 폴리필 라이브러리
- [native-promise-only](https://github.com/getify/native-promise-only) : `ES6 Promise` 스펙을 엄격히 따르는 폴리필 라이브러리.

#### 확장 라이브러리

- [q](https://github.com/kriskowal/q) : `Promise`와 `Deferred` 구현 라이브러리. Node.js 환경을 위한 파일 API 쩨공. 다양한 환경 지원을 위한 `Q-IO` 인터페이스 제공.
- [bluebird](https://github.com/petkaantonov/bluebird) : 취소 기능, 진행 정도 파악 기능 제공.

두 라이브러리 모두 문서화가 매우 뛰어나다고 한다.

### 5.2 Promise.resolve와 Thenable

#### 5.2.1 Web Notification

- [MDN | Web Noticications](https://developer.mozilla.org/ko/docs/Web/API/notification)
- [Can I use Web Noticications](https://caniuse.com/#feat=notifications) ~~**(IE는 11도 지원이 안된다...)**~~

다음과 같이 알람 출력

```javascript
new Notification('Hi');
```

하지만 생성자로 인스턴스를 생성하기 위해서는 허가를 받아야 한다

허가 결과는 `Notification.permission`으로 알 수 있다. 값은 **`granted`**, **`denied`**가 있다.

알림 허가창은 `Notification.requestPermission` 호출로 가능하며, 사용자의 선택 결과를 콜백에 매개변수로 넘긴다.

허가한 경우에만 생성자로 알람을 할 수 있지만 불허한 경우 인스턴스를 생성해도 아무 동작을 하지 않는다.

#### 5.2.2 Web Notifications 래핑

언제나 그렇듯 먼저 콜백 스타일로 예제 진행

```javascript
function notifyMessage(message, options, callback){
    var notification = null;

    if(Notification && Notification.permission === 'granted'){
        notification = new Notification(message, options);
        callback(null, notification);
    } else if (Notification.requestPermission) {
        Notification.requestPermission(function(status){
            if(Notification.permission !== status){
                Notification.permission = status;
            }
            
            if(status === 'granted'){
                notification = new Noticications(message, options);
                callback(null, notification);
            } else {
                callback(new Error('User denied'));
            }
        });
    } else {
        callback(new Error('Doesn\'t support Notification API'));
    }
}

notifyMessage('Hi!', {}, function(error, notification){
    if(error) return console.error(error);

    console.log(notification);
})
```

다음은 프로미스로 작성

```javascript
function notifyMessageAsPromise(message, options){
    return new Promise(function(resolve, reject){
        notifyMessage(message, options, function(error, notification){
            error ? reject(error) : resolve(notification);
        });
    });
}

notifyMessageAsPromise('Hi!').then(noti => {
    console.log(noti);
}).catch(err => {
    console.error(err)
})
```

thenable 코드

```javascript
function notifyMessageAsThenable(message, options){
    return {
        then : function(resolve, reject){
            notifyMessage(message, options, function(error, notification){
                error ? reject(error) : resolve(notification);
            });
        }
    };
}

Promise.resovle(notifyMessageAsThenable('Hi')).then(function(notification){
    console.log(notification);
}).catch(function(error){
    console.error(error);
})
```

#### 5.2.3 Thenable에 대해

프로미스에 **직접** 의존하지 않지만 인터페이스는 스펙을 따르고 있으므로 **간접적**으로 프로미스에 의존한다.
이는 콜백과 프로미스 둘 다 지원하는 방법이다. 하지만 라이브러리의 API로써는 어중간한 방법이므로 자주 볼 수 있는 방식은 아니다. `thenable`객체를 사용하기 위해 사용자가 `then`이나 `Promise.resolve(thenable)`에 대한 이해가 필요하므로 공개 API보단 내부적으로 사용하는 경우가 많다.

`thenable`은 프로미스 라이브러리간 상호 변환 시 가장 많이 사용한다.

```javascript
var Q = require('Q');

// ES6 Promise
var promise = new Promise(function(resolve){
    resolve(1);
});

// Q 객체로 변환
Q(promise).then(function(value){
    console.log(value);
}).finally(function(){
    console.log('finally');
});
```

`then()`이 이기 때문에 네이티브 객체는 물론 라이브러리 객체간 변환이 가능하다. `thenable`은 보통 라이브러리 내부에서만 사용하기 때문에 자주 볼 수 없지만 프로미스에서 꼭 알아야 할 개념이다.

### 5.3 throw 대신 reject 사용

프로미스 추상화 로직은 기본적으로 `try-catch`되는 것과 동일. 

`throw`가 발생해도 프로그램은 종료되지 않고 프로미스 객체의 상태가 `Rejected`된다.

```javascript
let promise = new Promise((resolve, reject) => {
    throw new Error('message');
});

promise.catch(error => {
    console.error(error.message);
});


// 위 처럼 작성해도 되지만 reject()를 사용하는 것이 일반적이다
let promise = new Promise((resolve, reject) => {
    reject(new Error('message'));
});
```

`reject()`를 사용하면

1. 의도한 예외인지 예기치 않은 오류인지 구별할 수 있다.
2. 예를 들어 크롬 개발 도구는 예외가 발생했을 때 디버거가 자동으로 그 위치를 break하는 기능이 있다.
3. 프로미스에서 직접 `throw`한다면 디버거는 중단된다.
4. 이는 디버깅 목적과 관계없는 곳에서 중단될 수 있기 때문에 옳지 않다.

하지만 다음처럼 `then()`에서 `reject()`를 사용하고 싶은 경우엔 어떨까?

```javascript
let promise = Promise.resolve();

promise.then(value => {
    setTimeout(() => {
        // 처리가 1초 이상 지나면 reject(2)
    }, 1000);

    // 시간이 걸리는 처리 수행(1)
    somethingHardWork();
}).catch(error => {
    // 타임아웃 에러 처리(3)
})
```

then 안에서 reject를 사용하고 싶지만 콜백함수에 전달된것은 이전 프로미스 객체의 리턴값일 뿐이다.

5.5절에서 프로미스를 사용한 타임아웃 처리를 알아보겠지만 이번 절은 then에서 reject를 사용하는 법을 알아본다.

먼저 `then()`의 동작에 대해 생각해본다.

1. then()으로 등록한 콜백은 값을 반환할 수 있다.

2. 반환값은 다음 then()이나 catch()의 콜백에 전달된다.

3. **이때 반환 값은 원시 타입뿐 아니라 프로미스 객체도 가능하다**

4. 반환값이 프로미스 객체인 경우 객체의 상태에 따라 어느 함수가 호출될지 결정된다.

```javascript
let promise = Promise.resolve();

promise.then(() => {
    let retPromise = new Promise((resolve, reject) => {
        // resolve 또는 reject 호출
        reject(new Error('this promise is rejected'));
    });

    return retPromise;

    // 혹은
    return Promise.reject(new Error('this promise is rejected'));
}).then(onFulfilled, onRejected)
```

### 5.4 Deferred와 Promise

`Deferred`는 프로미스를 랩핑하고 있으며 상태를 조작할 수 있는 메서드가 구현돼있다.(프로미스를 래핑하지 않은 Deferred도 있다.)

```javascript
// Deferred 구현
function Deferred(){
    this.promise = new Promise((resolve, reject) => {
        this._resolve = resolve;
        this._reject = reject;
    }).bind(this);
}

Deferred.prototype.resolve = function (value){
    this._resolve.call(this.promise, value);
}
Deferred.prototype.reject = function (reason){
    this._reject.call(this.promise, reason);
}
```

1.3절에서 사용한 `getURL()`을 Deferred로 재작성한다.

```javascript
function getURL(URL){
    let deferred = new Deferred();
    let req = new XMLHttpRequest();

    req.open('GET', URL, true);
    req.onload = function(){
        if(req.status === 200){
            deferred.resolve(req.responseText);
        } else {
            deferred.reject(new Error(req.statusText));
        }
    };

    req.onerror = function(){
        deferred.reject(new Error(req.statusText));
    }

    req.send();

    return deferred.promise;
}

const URL = 'http://httpbin.org/get';

getURL(URL).then(value => {
    console.log(value);
}).catch(error => {
    console.error(error.message);
})
```

```javascript
// 프로미스 구현
function getURL(URL){
    return new Promise((resolve, reject) => {
        let req = new XMLHttpRequest();

        req.open('GET', URL, true):

        req.onload = () => {
            if(req.status === 200){
                resolve(req.responseText);
            } else {
                reject(new Error(req.responseText));
            }
        }

        req.onerror = () => {
            reject(new Error(req.responseText));
        }

        req.send();
    });
}
```

큰맥락은 같으며, 특수한 메서드를 이용해 상태흐름을 제어할 수 있다.

- 프로미스 구현은 비동기 로직을 `new Promise()`로 감싸고 있다.

- `Deferred`는 감싸지 않기 떄문에 중첩이 줄어든다.

- `Deferred`는 처리 중 예상치 못한 오류가 발생하면 핸들링하지 못함다.

프로미스로 구현한 `getURL()`은 프로미스 객체를 반환할 뿐 아무 작업도 하지 않는다.

전체적인 비동기 로직은 프로미스에서 추상화되며 `resolve()`, `reject()`를 호출할 시점도 알기 쉽다.

*반면* `Deferred`는 함수형으로 문제를 해결하는 것이 아니라 deferred 객체를 생성하고

임의의 시점에서 `resolve()`, `reject()`를 호출하여 문제를 해결한다.

**`Promise`는 비동기 로직과 상태를 모두 추상화한 객체이고, `Deferred`는 상태만 추상화한다.**

#### 5.4.1 정리

- `Promise`란 미래 어느 시점에 정상/비정상 처리가 완료될 것을 예약한 객체
- `Deferred`는 아직 처리가 끝나지 않았다는 상태를 가리키는 객체
- 처리가 끝났을 땐 프로미스를 이용해 결과를 취득할 수 있도록 구조화됨
