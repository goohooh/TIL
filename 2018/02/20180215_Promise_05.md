# JavaScript Promise
> 한빛미디어 [리얼타임] JavaScript Promise

## 5. Promise 고급

- 프로미스로 `Web Notification API` 다루기
- `throw` 대신 `reject`를 사용해야 하는 이유
- `Deffered`와 `Promise`의 관계
- 다양한 라이브러리

### 5.1 Promise 라이브러리

#### 폴리필

- [es6-promise](https://github.com/stefanpenner/es6-promise) : `Promise/A+` 스펙을 호환하는 RSVP.js 기반의 폴리필 라이브러리
- [native-promise-only](https://github.com/getify/native-promise-only) : `ES6 Promise` 스펙을 엄격히 따르는 폴리필 라이브러리.

#### 확장 라이브러리

- [q](https://github.com/kriskowal/q) : `Promise`와 `Deferred` 구현 라이브러리. Node.js 환경을 위한 파일 API 쩨공. 다양한 환경 지원을 위한 `Q-IO` 인터페이스 제공.
- [bluebird](https://github.com/petkaantonov/bluebird) : 취소 기능, 진행 정도 파악 기능 제공.

두 라이브러리 모두 문서화가 매우 뛰어나다고 한다.

### 5.2 Promise.resolve와 Thenable

#### 5.2.1 Web Notification

- [MDN | Web Noticications](https://developer.mozilla.org/ko/docs/Web/API/notification)
- [Can I use Web Noticications](https://caniuse.com/#feat=notifications) ~~**(IE는 11도 지원이 안된다...)**~~

다음과 같이 알람 출력

```javascript
new Notification('Hi');
```

하지만 생성자로 인스턴스를 생성하기 위해서는 허가를 받아야 한다

허가 결과는 `Notification.permission`으로 알 수 있다. 값은 **`granted`**, **`denied`**가 있다.

알림 허가창은 `Notification.requestPermission` 호출로 가능하며, 사용자의 선택 결과를 콜백에 매개변수로 넘긴다.

허가한 경우에만 생성자로 알람을 할 수 있지만 불허한 경우 인스턴스를 생성해도 아무 동작을 하지 않는다.

#### 5.2.2 Web Notifications 래핑

언제나 그렇듯 먼저 콜백 스타일로 예제 진행

```javascript
function notifyMessage(message, options, callback){
    var notification = null;

    if(Notification && Notification.permission === 'granted'){
        notification = new Notification(message, options);
        callback(null, notification);
    } else if (Notification.requestPermission) {
        Notification.requestPermission(function(status){
            if(Notification.permission !== status){
                Notification.permission = status;
            }
            
            if(status === 'granted'){
                notification = new Noticications(message, options);
                callback(null, notification);
            } else {
                callback(new Error('User denied'));
            }
        });
    } else {
        callback(new Error('Doesn\'t support Notification API'));
    }
}

notifyMessage('Hi!', {}, function(error, notification){
    if(error) return console.error(error);

    console.log(notification);
})
```

다음은 프로미스로 작성

```javascript
function notifyMessageAsPromise(message, options){
    return new Promise(function(resolve, reject){
        notifyMessage(message, options, function(error, notification){
            error ? reject(error) : resolve(notification);
        });
    });
}

notifyMessageAsPromise('Hi!').then(noti => {
    console.log(noti);
}).catch(err => {
    console.error(err)
})
```

thenable 코드

```javascript
function notifyMessageAsThenable(message, options){
    return {
        then : function(resolve, reject){
            notifyMessage(message, options, function(error, notification){
                error ? reject(error) : resolve(notification);
            });
        }
    };
}

Promise.resovle(notifyMessageAsThenable('Hi')).then(function(notification){
    console.log(notification);
}).catch(function(error){
    console.error(error);
})
```

#### 5.2.3 Thenable에 대해

프로미스에 **직접** 의존하지 않지만 인터페이스는 스펙을 따르고 있으므로 **간접적**으로 프로미스에 의존한다.
이는 콜백과 프로미스 둘 다 지원하는 방법이다. 하지만 라이브러리의 API로써는 어중간한 방법이므로 자주 볼 수 있는 방식은 아니다. `thenable`객체를 사용하기 위해 사용자가 `then`이나 `Promise.resolve(thenable)`에 대한 이해가 필요하므로 공개 API보단 내부적으로 사용하는 경우가 많다.

`thenable`은 프로미스 라이브러리간 상호 변환 시 가장 많이 사용한다.

```javascript
var Q = require('Q');

// ES6 Promise
var promise = new Promise(function(resolve){
    resolve(1);
});

// Q 객체로 변환
Q(promise).then(function(value){
    console.log(value);
}).finally(function(){
    console.log('finally');
});
```

`then()`이 이기 때문에 네이티브 객체는 물론 라이브러리 객체간 변환이 가능하다. `thenable`은 보통 라이브러리 내부에서만 사용하기 때문에 자주 볼 수 없지만 프로미스에서 꼭 알아야 할 개념이다.

### throw 대신 reject 사용

프로미스 추상화 로직은 기본적으로 `try-catch`되는 것과 동일. 

`throw`가 발생해도 프로그램은 종료되지 않고 프로미스 객체의 상태가 `Rejected`된다.

```javascript
let promise = new Promise((resolve, reject) => {
    throw new Error('message');
});

promise.catch(error => {
    console.error(error.message);
});


// 위 처럼 작성해도 되지만 reject()를 사용하는 것이 일반적이다
let promise = new Promise((resolve, reject) => {
    reject(new Error('message'));
});
```

`reject()`를 사용하면

1. 의도한 예외인지 예기치 않은 오류인지 구별할 수 있다.
2. 예를 들어 크롬 개발 도구는 예외가 발생했을 때 디버거가 자동으로 그 위치를 break하는 기능이 있다.
3. 프로미스에서 직접 `throw`한다면 디버거는 중단된다.
4. 이는 디버깅 목적과 관계없는 곳에서 중단될 수 있기 때문에 옳지 않다.

하지만 다음처럼 `then()`에서 `reject()`를 사용하고 싶은 경우엔 어떨까?

```javascript
let promise = Promise.resolve();

promise.then(value => {
    setTimeout(() => {
        // 처리가 1초 이상 지나면 reject(2)
    }, 1000);

    // 시간이 걸리는 처리 수행(1)
    somethingHardWork();
}).catch(error => {
    // 타임아웃 에러 처리(3)
})
```

then 안에서 reject를 사용하고 싶지만 콜백함수에 전달된것은 이전 프로미스 객체의 리턴값일 뿐이다.

5.5절에서 프로미스를 사용한 타임아웃 처리를 알아보겠지만 이번 절은 then에서 reject를 사용하는 법을 알아본다.

먼저 `then()`의 동작에 대해 생각해본다.

1. then()으로 등록한 콜백은 값을 반환할 수 있다.

2. 반환값은 다음 then()이나 catch()의 콜백에 전달된다.

3. **이때 반환 값은 원시 타입뿐 아니라 프로미스 객체도 가능하다**

4. 반환값이 프로미스 객체인 경우 객체의 상태에 따라 어느 함수가 호출될지 결정된다.

```javascript
let promise = Promise.resolve();

promise.then(() => {
    let retPromise = new Promise((resolve, reject) => {
        // resolve 또는 reject 호출
        reject(new Error('this promise is rejected));'))
    });

    return retPromise;
}).then(onFulfilled, onRejected)
```